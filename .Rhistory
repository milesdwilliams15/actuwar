by = post1950
) +
labs(
color = "Period"
) +
theme(
legend.position.inside = c(.2, .25),
legend.title = element_text(size = 8)
)
ibm_sim(
model_fit,
its = 200,
newdata = data.frame(
pop = mean(wars$pop),
post1950 = unique(wars$post1950),
dem = mean(wars$dem)
),
se = T
) -> sim_data
llplot(
sim_data,
pred,
by = post1950
) +
labs(
color = "Period"
) +
theme(
legend.position.inside = c(.2, .25),
legend.title = element_text(size = 8)
)
sim_data |>
group_by(post1950) |>
boot_p(pred, thresh = 16e06, its = 200) |>
ggplot() +
aes(post1950, mean, ymin = lower, ymax = upper) +
geom_pointrange()
## estimate the model
ibm(
outcome = fat,
mu = ~ log(pop) + post1950 + dem,
alpha = ~ log(pop) + post1950 + dem,
theta = ~ log(pop) + post1950 + dem,
data = wars
) -> model_fit
## estimate the model
ibm(
outcome = fat,
mu = ~ log(pop) + maj + dem,
alpha = ~ log(pop) + maj + dem,
theta = ~ log(pop) + maj + dem,
data = wars
) -> model_fit
## estimate the model
ibm(
outcome = fat,
mu = ~ log(pop) + maj + dem,
alpha = ~ log(pop) + maj + dem,
theta = ~ log(pop) + maj + dem,
data = wars,
its = 500
) -> model_fit
rm(list = ls())
devtools::document()
library(furrr)
cores <- availableCores() - 1
plan(multisession, workers = cores)
## estimate the model
ibm(
outcome = fat,
mu = ~ log(pop) + maj + dem,
alpha = ~ log(pop) + maj + dem,
theta = ~ log(pop) + maj + dem,
data = wars,
its = 200
) -> model_fit
ibm_sim(
model_fit,
newdata = data.frame(
pop = mean(wars$pop),
post1950 = mean(wars$maj),
dem = c(-5, 0, 5)
),
se = T
) -> sim_data
llplot(
sim_data,
pred,
by = dem
) +
labs(
color = "Avg. Polity 2"
) +
scale_color_gradient2(
low = "red",
mid = "gray",
high = "blue",
guide = "legend",
breaks = c(-5, 0, 5)
) +
theme(
legend.position.inside = c(.2, .25),
legend.title = element_text(size = 8)
)
llplot(
sim_data,
pred,
by = dem
) +
labs(
color = "Avg. Polity 2"
) +
scale_color_gradient2(
low = "red",
mid = "gray",
high = "blue",
guide = "legend",
breaks = c(-5, 0, 5)
) +
theme(
legend.position = c(.2, .25),
legend.title = element_text(size = 8)
)
llplot(
sim_data,
pred,
by = dem
) +
labs(
color = "Avg. Polity 2"
) +
scale_color_gradient2(
low = "red",
mid = "gray",
high = "blue",
guide = "legend",
breaks = c(-5, 0, 5)
) +
theme(
legend.position = c(.2, .25),
legend.title = element_text(size = 8)
)
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
sim_data |>
group_by(dem) |>
boot_p(pred, thresh = 16e06, its = 200) |>
ggplot() +
aes(as.factor(dem), mean, ymin = lower, ymax = upper) +
geom_pointrange()
sim_data |>
group_by(dem) |>
boot_p(pred, thresh = 16e06, its = 200) |>
ggplot() +
aes(as.factor(dem), estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
sim_data |>
group_by(dem) |>
boot_p(pred, thresh = 16e06, ci = 0.834) |>
ggplot() +
aes(as.factor(dem), estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
#'
#' This function allows you to simulate random draws from an
#' inverse Burr model fit using the `ibm()` function.
#'
#' @param data A data object. Can be either grouped or un-grouped.
#' @param var The variable for which Pr(X > x) will be computed.
#' @param thresh A numerical threshold for which Pr(X > x) is computed. If missing, an error will be returned.
#' @param its The number bootstrap iterations. The default is 1,000.
#' @param ci A value between 0 and 1 indicating the quantile confidence interval level to be returned. 0.95 is the default.
#' @export
boot_p <- function(data, var, thresh, its = 1000, ci = 0.95) {
## return error if val is missing
if(missing(thresh)) {
stop("Option 'thresh' is missing. You should specify a threshold value for which to compute Pr(X > x).")
}
## bootstrap the data and get Pr(X > x)
data |>
dplyr::mutate(
x = !!dplyr::enquo(var)
) -> data
1:its |>
furrr::future_map_dfr(
~ data |>
dplyr::sample_n(nrow(data), T) |>
dplyr::summarize(
prob = mean(x > thresh),
.groups = "keep"
),
.options = furrr::furrr_options(seed = T)
) -> boot_out
## return a summary of bootstrapped Pr(X > x)
boot_out |>
dplyr::summarize(
estimate = data |>
dplyr::summarize(
estimate = mean(x > thresh)
) |> dplyr::pull(estimate),
boot_mean = mean(prob),
boot_median = median(prob),
boot_se = sd(prob),
boot_lower = quantile(prob, 1 - (ci + (1 - ci) / 2)),
boot_upper = quantile(prob, ci + (1 - ci) / 2),
sims = its
)
}
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
#'
#' This function allows you to simulate random draws from an
#' inverse Burr model fit using the `ibm()` function.
#'
#' @param data A data object. Can be either grouped or un-grouped.
#' @param var The variable for which Pr(X > x) will be computed.
#' @param thresh A numerical threshold for which Pr(X > x) is computed. If missing, an error will be returned.
#' @param its The number bootstrap iterations. The default is 1,000.
#' @param ci A value between 0 and 1 indicating the quantile confidence interval level to be returned. 0.95 is the default.
#' @export
boot_p <- function(data, var, thresh, its = 1000, ci = 0.95) {
## return error if val is missing
if(missing(thresh)) {
stop("Option 'thresh' is missing. You should specify a threshold value for which to compute Pr(X > x).")
}
## get the observed Pr(X > x)
data |>
dplyr::mutate(
x = !!dplyr::enquo(var)
) -> data
data |>
dplyr::summarize(
estimate = mean(x > thresh)
) -> obs_out
## bootstrap the data and get Pr(X > x)
1:its |>
furrr::future_map_dfr(
~ data |>
dplyr::sample_n(nrow(data), T) |>
dplyr::summarize(
prob = mean(x > thresh),
.groups = "keep"
),
.options = furrr::furrr_options(seed = T)
) -> boot_out
## return a summary of bootstrapped Pr(X > x)
boot_out |>
dplyr::summarize(
boot_mean = mean(prob),
boot_median = median(prob),
boot_se = sd(prob),
boot_lower = quantile(prob, 1 - (ci + (1 - ci) / 2)),
boot_upper = quantile(prob, ci + (1 - ci) / 2),
sims = its
) -> boot_out
dplyr::bind_cols(obs_out, boot_out)
}
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
#'
#' This function allows you to simulate random draws from an
#' inverse Burr model fit using the `ibm()` function.
#'
#' @param data A data object. Can be either grouped or un-grouped.
#' @param var The variable for which Pr(X > x) will be computed.
#' @param thresh A numerical threshold for which Pr(X > x) is computed. If missing, an error will be returned.
#' @param its The number bootstrap iterations. The default is 1,000.
#' @param ci A value between 0 and 1 indicating the quantile confidence interval level to be returned. 0.95 is the default.
#' @export
boot_p <- function(data, var, thresh, its = 1000, ci = 0.95) {
## return error if val is missing
if(missing(thresh)) {
stop("Option 'thresh' is missing. You should specify a threshold value for which to compute Pr(X > x).")
}
## get the observed Pr(X > x)
data |>
dplyr::mutate(
x = !!dplyr::enquo(var)
) -> data
data |>
dplyr::summarize(
estimate = mean(x > thresh)
) -> obs_out
## bootstrap the data and get Pr(X > x)
1:its |>
furrr::future_map_dfr(
~ data |>
dplyr::sample_n(nrow(data), T) |>
dplyr::summarize(
prob = mean(x > thresh),
.groups = "keep"
),
.options = furrr::furrr_options(seed = T)
) -> boot_out
## return a summary of bootstrapped Pr(X > x)
boot_out |>
dplyr::summarize(
boot_mean = mean(prob),
boot_median = median(prob),
boot_se = sd(prob),
boot_lower = quantile(prob, 1 - (ci + (1 - ci) / 2)),
boot_upper = quantile(prob, ci + (1 - ci) / 2),
sims = its
) -> boot_out
boot_out$estimate <- obs_out$estimate
boot_out
}
#'
#' This function allows you to simulate random draws from an
#' inverse Burr model fit using the `ibm()` function.
#'
#' @param data A data object. Can be either grouped or un-grouped.
#' @param var The variable for which Pr(X > x) will be computed.
#' @param thresh A numerical threshold for which Pr(X > x) is computed. If missing, an error will be returned.
#' @param its The number bootstrap iterations. The default is 1,000.
#' @param ci A value between 0 and 1 indicating the quantile confidence interval level to be returned. 0.95 is the default.
#' @export
boot_p <- function(data, var, thresh, its = 1000, ci = 0.95) {
## return error if val is missing
if(missing(thresh)) {
stop("Option 'thresh' is missing. You should specify a threshold value for which to compute Pr(X > x).")
}
## get the observed Pr(X > x)
data |>
dplyr::mutate(
x = !!dplyr::enquo(var)
) -> data
data |>
dplyr::summarize(
estimate = mean(x > thresh)
) -> obs_out
## bootstrap the data and get Pr(X > x)
1:its |>
furrr::future_map_dfr(
~ data |>
dplyr::sample_n(nrow(data), T) |>
dplyr::summarize(
prob = mean(x > thresh),
.groups = "keep"
),
.options = furrr::furrr_options(seed = T)
) -> boot_out
## return a summary of bootstrapped Pr(X > x)
boot_out |>
dplyr::summarize(
boot_mean = mean(prob),
boot_median = median(prob),
boot_se = sd(prob),
boot_lower = quantile(prob, 1 - (ci + (1 - ci) / 2)),
boot_upper = quantile(prob, ci + (1 - ci) / 2),
sims = its
) -> boot_out
if(nrow(obs_out) == 1) {
dplyr::bind_cols(obs_out, boot_out)
} else {
suppressMessage(dplyr::left_join(obs_out, boot_out))
}
}
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
#'
#' This function allows you to simulate random draws from an
#' inverse Burr model fit using the `ibm()` function.
#'
#' @param data A data object. Can be either grouped or un-grouped.
#' @param var The variable for which Pr(X > x) will be computed.
#' @param thresh A numerical threshold for which Pr(X > x) is computed. If missing, an error will be returned.
#' @param its The number bootstrap iterations. The default is 1,000.
#' @param ci A value between 0 and 1 indicating the quantile confidence interval level to be returned. 0.95 is the default.
#' @export
boot_p <- function(data, var, thresh, its = 1000, ci = 0.95) {
## return error if val is missing
if(missing(thresh)) {
stop("Option 'thresh' is missing. You should specify a threshold value for which to compute Pr(X > x).")
}
## get the observed Pr(X > x)
data |>
dplyr::mutate(
x = !!dplyr::enquo(var)
) -> data
data |>
dplyr::summarize(
estimate = mean(x > thresh)
) -> obs_out
## bootstrap the data and get Pr(X > x)
1:its |>
furrr::future_map_dfr(
~ data |>
dplyr::sample_n(nrow(data), T) |>
dplyr::summarize(
prob = mean(x > thresh),
.groups = "keep"
),
.options = furrr::furrr_options(seed = T)
) -> boot_out
## return a summary of bootstrapped Pr(X > x)
boot_out |>
dplyr::summarize(
boot_mean = mean(prob),
boot_median = median(prob),
boot_se = sd(prob),
boot_lower = quantile(prob, 1 - (ci + (1 - ci) / 2)),
boot_upper = quantile(prob, ci + (1 - ci) / 2),
sims = its
) -> boot_out
if(nrow(obs_out) == 1) {
dplyr::bind_cols(obs_out, boot_out)
} else {
suppressMessages(dplyr::left_join(obs_out, boot_out))
}
}
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834, its = 200) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
wars |>
# group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834, its = 200)
wars |>
group_by(post1950) |>
boot_p(fat, thresh = 1e06, ci = 0.834) |>
ggplot() +
aes(post1950, estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
sim_data |>
group_by(dem) |>
boot_p(pred, thresh = 16e06, ci = 0.834) |>
ggplot() +
aes(as.factor(dem), estimate, ymin = boot_lower, ymax = boot_upper) +
geom_pointrange()
devtools::document()
## Setup ----
# devtools::install_github("milesdwilliams15/actuwar")
library(actuwar)
## can I run in parallel?
library(furrr)
cores <- availableCores() - 1
plan(multisession, workers = cores)
ibm(
outcome = fat,
mu = ~ pop + mil + maj + dem + post1950,
alpha = ~ pop + mil + maj + dem + post1950,
theta = ~ pop + mil + maj + dem + post1950,
data = wars,
its = 2000
) -> ft
library(furrr)
cores <- availableCores() - 1
plan(multisession, workers = cores)
## estimate the model
ibm(
outcome = fat,
mu = ~ log(pop) + maj + dem,
alpha = ~ log(pop) + maj + dem,
theta = ~ log(pop) + maj + dem,
data = wars,
its = 200
) -> model_fit
ibm_sim(
model_fit,
newdata = data.frame(
pop = mean(wars$pop),
post1950 = mean(wars$maj),
dem = c(-5, 0, 5)
),
se = T
) -> sim_data
llplot(
sim_data,
pred,
by = dem
) +
labs(
color = "Avg. Polity 2"
) +
scale_color_gradient2(
low = "red",
mid = "gray",
high = "blue",
guide = "legend",
breaks = c(-5, 0, 5)
) +
theme(
legend.position = c(.2, .25),
legend.title = element_text(size = 8)
)
ibm_sim(
model_fit,
newdata = tibble(
pop = mean(wars$pop),
post1950 = mean(wars$maj),
dem = c(-5, 0, 5)
),
se = T
) -> sim_data
